**<h3>ПЗ-3 Свириденко Єва ЦК-31<h3>**
___
**Тема: Управління потоком виконання**
___
***Хід роботи:***

1. Повторити теоретичні відомості
2. Виконати три завдання з таблиці 2 відповідно до свого варіанту у таблиці 1.
- Кожне завдання має бути реалізовано як окремий клас.
- Кожен клас має складатись щонайменше з двох методів:
- public static void main(String[] agrs) - точка входу. Містить код, що кілька разів
знаходить результат завдання при різних значеннях аргументів та параметрів. Для
перевірки мають бути присутні як дозволені так і заборонені комбінації аргументів та
параметрів.
- Метод, що реалізує задане завдання. Метод має перевіряти аргументи і параметри
функції та у разі їх помилковості аварійно закінчувати свою роботу шляхом
викидання стандартного виключення IllegalArgumentException (дивись приклад). В
жодному разі цей метод не повинен напряму взаємодіяти з користувачем через
консоль або інший UI (ніколи не змішуйте бізнес-логіку та користувацький
інтерфейс).
- Клас може містити інші допоміжні методи.
3. Відповісти на контрольні питання
___


Варіант №13.

*Вирази №3, №10, №12.*
___

Код виконання завдання у папці src/lab03.

___


**Відповіді на контрольні питання**

---


***№1. Що таке структурне програмування?***



Структурне програмування - це методологія розробки програмного забезпечення, яка передбачає розбиття програми на логічні блоки (функції, процедури, методи) та використання базових керуючих конструкцій. Метою є підвищення читабельності, зручності налагодження і повторного використання коду.


---

***№2. Назвіть основні конструкції структурного програмування.***


Слідування (послідовність) - виконання інструкцій одна за одною.

Розгалуження - умовне виконання (if, if-else, switch).

Цикли - повторне виконання (while, do-while, for).


---

***№3. Назвіть основні принципи структурного програмування.***



Використання єдиної точки входу та виходу з підпрограм.

Мінімізація використання переходів (уникнення GOTO).

Декомпозиція задачі на підзадачі (модульність).

Використання простих і зрозумілих конструкцій управління потоком.

---



***№4. Поясніть, чому в більшості мов програмування не радять використовувати оператор GOTO, а в
мові Java його взагалі немає?***


GOTO створює неконтрольовані переходи, що призводить до спагеті-коду, ускладнює налагодження та супровід. Java спеціально не включає GOTO, замість цього пропонує структуровані оператори (if, switch, цикли) та мітки для контрольованого виходу з вкладених циклів.


---

***№5. Що таке спагеті-код?***


Спагеті-код - це код із заплутаними переходами та залежностями, що важко читається і підтримується. Зазвичай виникає через надмірне використання GOTO або хаотичну структуру програми.

---

***№6. Що таке проектування зверху-вниз? В чому його переваги?***


Це підхід, коли спочатку визначаються загальні цілі та структура програми, а потім вона розбивається на підзадачі та модулі.
*Переваги:*

Зручніше планувати та перевіряти логіку.

Легше масштабувати та підтримувати код.

Підходить для великих проєктів.


---

***№7. Що таке область видимості ідентифікатора?***


Область видимості - це частина коду, у якій доступна змінна або інший ідентифікатор. У Java змінна, оголошена в методі або блоці, доступна тільки всередині нього.

---

***№8. Що таке блок? Як блоки впливають на область видимості?***


Блок - це група інструкцій, укладених у фігурні дужки {}. Змінні, оголошені в блоці, існують і доступні лише всередині цього блоку.


---



***№9. Наведіть приклади, у яких випадках краще використовувати наступні оператори та конструкції:***



- if
- if-else
- ланцюги if-else if -else if...
- switch
- тернарна умовна операція ?:




if - коли є проста перевірка:

if (x > 0) System.out.println("Positive");


if-else - коли потрібні дві альтернативи:

if (x >= 18) System.out.println("Adult");
else System.out.println("Minor");


ланцюг if-else if — для кількох варіантів:

if (grade >= 90) System.out.println("A");
else if (grade >= 75) System.out.println("B");
else System.out.println("C");


switch - коли перевіряють одне значення на багато варіантів:

switch(day) {
    case 1: System.out.println("Monday"); break;
    case 2: System.out.println("Tuesday"); break;
    default: System.out.println("Other");
}


тернарна операція ?: - коротка перевірка:

String result = (x > 0) ? "Positive" : "Non-positive";





---



***№10. Наведіть приклади, у яких випадках краще використовувати наступні оператори та конструкції:***

- while
- do-while
- for


while - коли кількість ітерацій невідома:

while (n > 0) { n--; }


do-while - коли цикл повинен виконатися хоча б один раз:

do { n--; } while (n > 0);


for - коли кількість ітерацій відома:

for (int i=0; i<5; i++) { System.out.println(i); }






---




***№11. Чим оператор break відрізняється від оператора continue?***




break — вихід з циклу повністю.

continue — пропуск поточної ітерації та перехід до наступної.



---

***№12. Навіщо у мові Java є мітки, якщо немає goto?***




Мітки використовуються з break і continue для керування вкладеними циклами, наприклад:

outer:
for(int i=0; i<3; i++) {
  for(int j=0; j<3; j++) {
    if(j==1) break outer;
  }
}




---


***№13. До якого результату призведе виконання наступного фрагменту коду? Перевірте. Поясніть.***



boolean a = false;
boolean b = false;
if (a=false) {
System.out.println(&quot;a is false&quot;);
}
if (b=true) {
System.out.println(&quot;b is true&quot;);
}
if (a=b) {
System.out.println(&quot;a = b&quot;);
}





boolean a = false;
boolean b = false;

if (a = false) {  // присвоєння, a стає false, умова = false
    System.out.println("a is false"); // не виконається
}
if (b = true) {   // присвоєння, b стає true, умова = true
    System.out.println("b is true");  // виконається
}
if (a = b) {      // a = b (true), a стає true
    System.out.println("a = b");      // виконається
}
Вивід:

csharp
Копіювати код
b is true  
a = b  





---







***№14. До якого результату призведе виконання наступного фрагменту коду? Перевірте. Поясніть.***




int a = 1;
a++;
++a;
switch(a) {
case 1: System.out.println(&quot;1&quot;);
case 2: System.out.println(&quot;2&quot;);
case 3: System.out.println(&quot;3&quot;);
case 4: System.out.println(&quot;4&quot;);
}


int a = 1;
a++;  // a = 2
++a;  // a = 3
switch (a) {
    case 1: System.out.println("1");
    case 2: System.out.println("2");
    case 3: System.out.println("3");
    case 4: System.out.println("4");
}
Вивід:

Копіювати код
3  
4
(Співпадіння case 3, далі йде "провалювання" без break).






---


***№15. До якого результату призведе виконання наступного фрагменту коду (true/false)? Перевірте.
Поясніть.***





double sum = 0;
// Let&#39;s find: 1 + 1/2 + 1/3 + 1/4 + 1/5 + ...
for(int i=1; i&lt;10; i++) {
sum = sum + 1/i;
}
System.out.println(sum &gt; 1);






double sum = 0;
for (int i = 1; i < 10; i++) {
    sum = sum + 1 / i; // 1/i — цілочисельне ділення, результат = 0 для i>1
}
System.out.println(sum > 1);
Для i=1: 1/1 = 1. Для i=2..9: 1/i = 0 (ціле ділення).
Отже, sum = 1. Порівняння sum > 1 → 1 > 1 → false.

Щоб отримати правильний результат з дробами, треба писати 1.0 / i.

Вивід:

arduino
Копіювати код
false






---

